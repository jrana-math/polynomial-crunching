--Okay, so here's what I'm thinking.
--What we want is for each outer loop to generate a new set of weights to run our other program with.
--The inner loop is meant to form individual sets of weights, and the outer loop forms a list of all possible weight sets.
--We can build each weight set by converting i to binary and then listing its digits.
--Unfortunately, I don't think Macaulay has any built-in stuff relating to binary numbers.
--So what we need to do is write something in the body of the inner loop that will add a "1" to the list
--if the binary representation of i has a 1 there and a 0 otherwise.
--I don't know how to do that yet but it seems like we should be able to figure it out today.


weights = {};
weight = {};

for i to 2^14-1 do 
(
    weight = {};
    for j from 1 to 14 do
    (
        k = 1;
	if i%(2^j) < 2^(j-1) then k = 0;
	weight = append(weight, k);
    );
    weights = append(weights, weight);
);

for a to #weights-1 do
(
    R = QQ[splice {x_11 .. x_17, x_21 .. x_27}, MonomialOrder=>{Weights=>weights#a, Lex}];
    M = genericMatrix(R, 2, 7);
    L = subsets(7, 6);
    notgroebner = {};

    for i to (#L-1) do 
    (
	M1 = matrix{{1, 1, 1}, {M_(0, L#i#0), M_(0, L#i#1), M_(0, L#i#2)}, {M_(1, L#i#0), M_(1, L#i#1), M_(1, L#i#2)}};
	M2 = matrix{{1, 1, 1}, {M_(0, L#i#0), M_(0, L#i#3), M_(0, L#i#4)}, {M_(1, L#i#0), M_(1, L#i#3), M_(1, L#i#4)}};
	M3 = matrix{{1, 1, 1}, {M_(0, L#i#1), M_(0, L#i#3), M_(0, L#i#5)}, {M_(1, L#i#1), M_(1, L#i#3), M_(1, L#i#5)}};
	M4 = matrix{{1, 1, 1}, {M_(0, L#i#2), M_(0, L#i#4), M_(0, L#i#5)}, {M_(1, L#i#2), M_(1, L#i#4), M_(1, L#i#5)}};
	M5 = matrix{{1, 1, 1}, {M_(0, L#i#0), M_(0, L#i#1), M_(0, L#i#3)}, {M_(1, L#i#0), M_(1, L#i#1), M_(1, L#i#3)}};
	M6 = matrix{{1, 1, 1}, {M_(0, L#i#0), M_(0, L#i#2), M_(0, L#i#4)}, {M_(1, L#i#0), M_(1, L#i#2), M_(1, L#i#4)}};
	M7 = matrix{{1, 1, 1}, {M_(0, L#i#1), M_(0, L#i#2), M_(0, L#i#5)}, {M_(1, L#i#1), M_(1, L#i#2), M_(1, L#i#5)}};
	M8 = matrix{{1, 1, 1}, {M_(0, L#i#3), M_(0, L#i#4), M_(0, L#i#5)}, {M_(1, L#i#3), M_(1, L#i#4), M_(1, L#i#5)}};
	g = det(M1)*det(M2)*det(M3)*det(M4)-det(M5)*det(M6)*det(M7)*det(M8);
	notgroebner = append(notgroebner, g);
    );

    I = ideal(notgroebner);
    groebner = gens gb I;
    notgroebnersize = #notgroebner;
    groebnersize = numgens source groebner;

    n=0;
    for i to (groebnersize - 1) do (for j to (notgroebnersize-1) do (if groebner_(0, i) == notgroebner#j then n=n+1));
    text = "The total number of matches is ";
    nonumber = toString(n);
    dot = ".";
    p = text | nonumber | dot;
    print p
)

--The above code works!!!!


-- We start by defining n. Then we create an empty set S so that we can add elements to it. The next two for loops put
-- n zeros and n ones in S, respectively. Then, we let P be all the permutations of S and then U be the subset of P which
-- contains all combinations of the elements of S but without repeating them.

n=7;
S = {};
for i to n-1 do (S = append(S, 0));
for i to n-1 do (S = append(S, 1));
P = permutations S;
U = unique(P);

-- The next goal is to somehow use the elements of U as weights in the ring R. There might be a way to define the variables 
-- of R with a for-loop, so that we don't need to do anything manually besides assigning a value to n, but we can figure 
-- this out after we make the program work. The idea here is to create a for loop (line 43) that uses all possible weights
-- for a fixed natural number n and define the polynomial ring accordingly (line 44). Then, from line 45 on, I pasted the
-- codes Andrew wrote yesterday. Additionally to what he stressed on the other file, if we want to change the value of n, we
-- need to replace the number 7 to whatever natural greater than 5 with which we would like to work on lines 28, 44 (twice),
-- 45 and 46.

for j to #U-1 do
(R = QQ[splice {x_11 .. x_17, x_21 .. x_27}, MonomialOrder => {Weights => U#j, Lex}];
M = genericMatrix(R, 2, 7);
L = subsets(7, 6);
notgroebner = {};

for i to (#L-1) do 
(
M1 = matrix{{1, 1, 1}, {M_(0, L#i#0), M_(0, L#i#1), M_(0, L#i#2)}, {M_(1, L#i#0), M_(1, L#i#1), M_(1, L#i#2)}};
M2 = matrix{{1, 1, 1}, {M_(0, L#i#0), M_(0, L#i#3), M_(0, L#i#4)}, {M_(1, L#i#0), M_(1, L#i#3), M_(1, L#i#4)}};
M3 = matrix{{1, 1, 1}, {M_(0, L#i#1), M_(0, L#i#3), M_(0, L#i#5)}, {M_(1, L#i#1), M_(1, L#i#3), M_(1, L#i#5)}};
M4 = matrix{{1, 1, 1}, {M_(0, L#i#2), M_(0, L#i#4), M_(0, L#i#5)}, {M_(1, L#i#2), M_(1, L#i#4), M_(1, L#i#5)}};
M5 = matrix{{1, 1, 1}, {M_(0, L#i#0), M_(0, L#i#1), M_(0, L#i#3)}, {M_(1, L#i#0), M_(1, L#i#1), M_(1, L#i#3)}};
M6 = matrix{{1, 1, 1}, {M_(0, L#i#0), M_(0, L#i#2), M_(0, L#i#4)}, {M_(1, L#i#0), M_(1, L#i#2), M_(1, L#i#4)}};
M7 = matrix{{1, 1, 1}, {M_(0, L#i#1), M_(0, L#i#2), M_(0, L#i#5)}, {M_(1, L#i#1), M_(1, L#i#2), M_(1, L#i#5)}};
M8 = matrix{{1, 1, 1}, {M_(0, L#i#3), M_(0, L#i#4), M_(0, L#i#5)}, {M_(1, L#i#3), M_(1, L#i#4), M_(1, L#i#5)}};
g = det(M1)*det(M2)*det(M3)*det(M4)-det(M5)*det(M6)*det(M7)*det(M8);
notgroebner = append(notgroebner, g);
);

I = ideal(notgroebner);
groebner = gens gb I;
notgroebnersize = #notgroebner
groebnersize = numgens source groebner

n=0;
for i to (groebnersize - 1) do (for j to (notgroebnersize-1) do (if groebner_(0, i) == notgroebner#j then n=n+1));
text = "The total number of matches is ";
nonumber = toString(n);
dot = ".";
p = text | nonumber | dot;
p)


