--Okay, so here's what I'm thinking.
--What we want is for each outer loop to generate a new set of weights to run our other program with.
--The inner loop is meant to form individual sets of weights, and the outer loop forms a list of all possible weight sets.
--We can build each weight set by converting i to binary and then listing its digits.
--Unfortunately, I don't think Macaulay has any built-in stuff relating to binary numbers.
--So what we need to do is write something in the body of the inner loop that will add a "1" to the list
--if the binary representation of i has a 1 there and a 0 otherwise.
--I don't know how to do that yet but it seems like we should be able to figure it out today.


weights = {};
weight = {};

for i to 2^14-1 do 
(
    weight = {};
    for j from 1 to 14 do
    (
        k = 1;
	if i%(2^j) < 2^(j-1) then k = 0;
	weight = append(weight, k);
    );
    weights = append(weights, weight);
);

matches = {};

for a to #weights-1 do
(
    R = QQ[splice {x_11 .. x_17, x_21 .. x_27}, MonomialOrder=>{Weights=>weights#a, Lex}];
    M = genericMatrix(R, 2, 7);
    L = subsets(7, 6);
    notgroebner = {};

    for i to (#L-1) do 
    (
	M1 = matrix{{1, 1, 1}, {M_(0, L#i#0), M_(0, L#i#1), M_(0, L#i#2)}, {M_(1, L#i#0), M_(1, L#i#1), M_(1, L#i#2)}};
	M2 = matrix{{1, 1, 1}, {M_(0, L#i#0), M_(0, L#i#3), M_(0, L#i#4)}, {M_(1, L#i#0), M_(1, L#i#3), M_(1, L#i#4)}};
	M3 = matrix{{1, 1, 1}, {M_(0, L#i#1), M_(0, L#i#3), M_(0, L#i#5)}, {M_(1, L#i#1), M_(1, L#i#3), M_(1, L#i#5)}};
	M4 = matrix{{1, 1, 1}, {M_(0, L#i#2), M_(0, L#i#4), M_(0, L#i#5)}, {M_(1, L#i#2), M_(1, L#i#4), M_(1, L#i#5)}};
	M5 = matrix{{1, 1, 1}, {M_(0, L#i#0), M_(0, L#i#1), M_(0, L#i#3)}, {M_(1, L#i#0), M_(1, L#i#1), M_(1, L#i#3)}};
	M6 = matrix{{1, 1, 1}, {M_(0, L#i#0), M_(0, L#i#2), M_(0, L#i#4)}, {M_(1, L#i#0), M_(1, L#i#2), M_(1, L#i#4)}};
	M7 = matrix{{1, 1, 1}, {M_(0, L#i#1), M_(0, L#i#2), M_(0, L#i#5)}, {M_(1, L#i#1), M_(1, L#i#2), M_(1, L#i#5)}};
	M8 = matrix{{1, 1, 1}, {M_(0, L#i#3), M_(0, L#i#4), M_(0, L#i#5)}, {M_(1, L#i#3), M_(1, L#i#4), M_(1, L#i#5)}};
	g = det(M1)*det(M2)*det(M3)*det(M4)-det(M5)*det(M6)*det(M7)*det(M8);
	notgroebner = append(notgroebner, g);
    );

    I = ideal(notgroebner);
    groebner = gens gb I;
    notgroebnersize = #notgroebner;
    groebnersize = numgens source groebner;

    n=0;
    for i to (groebnersize - 1) do (for j to (notgroebnersize-1) do (if groebner_(0, i) == notgroebner#j then n=n+1));
    text = "The total number of matches is ";
    nonumber = toString(n);
    dot = ".";
    p = text | nonumber | dot;
    print p;
    print weights#a;
    if n == #groebner then matches = append(matches, weights#a);
)

--The above code works!!!!





----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------


-- The sets weight and weights are different. weights is a collection of some 'weight's. They are both initialized as
-- the empty set (lines 89 and 90) because that way we can create whichever set we like just by adding its elements. 
-- weight is a string of ones and zeros. The frequency of one or zero happening varies between 0 and 7 while 
-- freq(0)+freq(1)=2n always holds.
-- We are more interested now in the case n=7, so that number means 'weights' is a set of vectors ('weight's) whose length  
-- is 14 and entries are completed by 7 ones and zeros. 
-- These 'weight's will be used along with the lex order to create several weight orders. 
-- The inner for loop we use (lines 95-100) is to characterize the sets called weight. Before it, we have a local variable
-- (line 94) that makes the set weight empty again, so we can repeat the process over and over. Immediately after the inner 
-- for loop (line 101) we use the function append(setS, elementK) that adds elementK to SetS. This is also used on line 98
-- to "add" the entries of the vectors weight.
--

weights = {};
weight = {};

for i to 2^14-1 do 
(
    weight = {};
    for j from 1 to 14 do
    (
        k = 1;
	if i%(2^j) < 2^(j-1) then k = 0;
	weight = append(weight, k);
    );
    weights = append(weights, weight);
);


--
--
--
--
--
--
--

for a to #weights-1 do
(
    R = ZZ/101[splice {x_11 .. x_17, x_21 .. x_27}, MonomialOrder=>{Weights=>weights#a, Lex}];
    M = genericMatrix(R, 2, 7);
    L = subsets(7, 6);
    notgroebner = {};

    for i to (#L-1) do 
    (
	M1 = matrix{{1, 1, 1}, {M_(0, L#i#0), M_(0, L#i#1), M_(0, L#i#2)}, {M_(1, L#i#0), M_(1, L#i#1), M_(1, L#i#2)}};
	M2 = matrix{{1, 1, 1}, {M_(0, L#i#0), M_(0, L#i#3), M_(0, L#i#4)}, {M_(1, L#i#0), M_(1, L#i#3), M_(1, L#i#4)}};
	M3 = matrix{{1, 1, 1}, {M_(0, L#i#1), M_(0, L#i#3), M_(0, L#i#5)}, {M_(1, L#i#1), M_(1, L#i#3), M_(1, L#i#5)}};
	M4 = matrix{{1, 1, 1}, {M_(0, L#i#2), M_(0, L#i#4), M_(0, L#i#5)}, {M_(1, L#i#2), M_(1, L#i#4), M_(1, L#i#5)}};
	M5 = matrix{{1, 1, 1}, {M_(0, L#i#0), M_(0, L#i#1), M_(0, L#i#3)}, {M_(1, L#i#0), M_(1, L#i#1), M_(1, L#i#3)}};
	M6 = matrix{{1, 1, 1}, {M_(0, L#i#0), M_(0, L#i#2), M_(0, L#i#4)}, {M_(1, L#i#0), M_(1, L#i#2), M_(1, L#i#4)}};
	M7 = matrix{{1, 1, 1}, {M_(0, L#i#1), M_(0, L#i#2), M_(0, L#i#5)}, {M_(1, L#i#1), M_(1, L#i#2), M_(1, L#i#5)}};
	M8 = matrix{{1, 1, 1}, {M_(0, L#i#3), M_(0, L#i#4), M_(0, L#i#5)}, {M_(1, L#i#3), M_(1, L#i#4), M_(1, L#i#5)}};
	g = det(M1)*det(M2)*det(M3)*det(M4)-det(M5)*det(M6)*det(M7)*det(M8);
	notgroebner = append(notgroebner, g);
    );

--
--
--

    I = ideal(notgroebner);
    groebner = gens gb I;
    notgroebnersize = #notgroebner;
    groebnersize = numgens source groebner;
    
    --
    --
    --
    --
    --
    --
    --
    --
    --
    --
    
    n=0;
    flag=0;
    for i to groebnersize-1 do
    (
        flag=0;
        for j to notgroebnersize-1 do 
	(
	    --If we already have a match we move on to the next element of groebner.
	    if flag > 0 then break;
	    --Otherwise we search for a match.
	    for k from 1 to 100 do 
	    (
		--If we find a match then count it and break out.
	        if (k*groebner_(0, i) == notgroebner#j) then
		(
		    n=n+1;
		    flag=1;
		    --print k;
		    --print (k*groebner_(0, i)-notgroebner#j);
		    break;
		);
	    );
	);
	--Stop looking for matches if we know we don't have a groebner basis.
	if flag==0 then 
	(
	    --print "NO MATCH";
	    break;
	);
    );
    
    --
    --
    --
    
    matches = {};
    text = "The total number of matches is ";
    nonumber = toString(n);
    dot = ".";
    p = text | nonumber | dot;
    print p;
    print weights#a;
    if n == groebnersize then matches = append(matches, weights#a);
    )
